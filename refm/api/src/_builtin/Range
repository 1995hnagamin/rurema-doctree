= class Range < Object

include Enumerable

範囲オブジェクトのクラス。
範囲オブジェクトは文字どおり何らかの意味での範囲を表します。数の範囲はもちろん、
日付の範囲や、「"a" から "z" まで」といった文字列の範囲を表すこともできます。

==== 作り方

範囲オブジェクトは、[[m:Range.new]] を用いるほか、範囲演算子（`..' または `...'）を
用いた [[ref:d:spec/operator#range]] で生成できます。
いずれの方法でも始端と終端を与えます。

#@samplecode 範囲オブジェクトの例
Range.new(1, 5) # 1 以上 5 以下
1..5            # 同上
1...5           # 1 以上 5 未満
#@end

この例で分かるように、範囲オブジェクトは終端を含む範囲も含まない範囲も表せます。

#@since 2.6.0
Ruby 2.6.0 からは、終端に nil を与えることで「終端を持たない範囲オブジェクト」
を作ることができるようになりました。

#@samplecode 終端を持たない範囲オブジェクト
p Range.new(1, nil) # 1 以上（上限無し）を表す
p(1..nil)           # 同上
p(1..)              # 同上（略した書き方）
#@end

#@since 2.7.0
また、Ruby 2.7.0 では始端に nil を与えることで「始端を持たない範囲オブジェクト」
を作ることもできるようになりました。

#@samplecode 始端を持たない範囲オブジェクト
p Range.new(nil, 5) # 5 以下（下限無し）を表す
p(nil..5)           # 同上
p(..5)              # 同上（略した書き方）
#@end

始端も終端も持たない範囲オブジェクトは「全範囲」を表します。

#@samplecode 始端も終端も持たない範囲オブジェクト
# 以下はすべて同じ範囲
p Range.new(nil, nil) # => nil..nil
p(nil..nil)           # => nil..nil
p(..nil)              # => nil..nil
p(nil..)              # => nil..nil
#@end

範囲式で両端を略した書き方はできません。

  p(..)  # => SyntaxError
  p(...) # Ruby 2.7 で導入されたメソッド引数の forward として解釈されてしまう

#@end
#@end

==== 機能

範囲オブジェクトは範囲を表しているので、基本的な機能として「ある値がその範囲に
含まれるか否かを判定する」ということがあります。

#@samplecode 値が範囲に含まれるかどうかを判定
p (1..5).cover?(6)  # => false
p (1..5).cover?(5)  # => true
p (1...5).cover?(5) # => false
#@end

[[m:Range#cover?]] メソッドでの判定には演算子 <=> が使われます。

当然、始端と終端は <=> メソッドで比較可能である（nil 以外を返す）必要が
あります。

範囲オブジェクトのもう一つの基本的機能は繰り返しの範囲を表すことです。

#@samplecode 繰り返しの範囲を範囲オブジェクトで表す
(3..5).each{ |i| p i }
# => 3
#    4
#    5

(3...5).each{ |i| p i }
# => 3
#    4
#@end

繰り返しの範囲を表す範囲オブジェクトは、始端が「次の値」を返す succ メソッドを
持たなければなりません。

Range クラスには [[c:Enumerable]] が include してあるので，[[m:Range#each]] に
基づき、Enumerable モジュールが提供する多様なメソッドを使うことができます。

=== 破壊的な変更

Ruby の Range クラスは immutable です。
つまり、オブジェクト自体を破壊的に変更することはできません。
ですので、一度生成された Range のオブジェクトの指し示す範囲は
決して変更することはできません。

  range = 1..10
  range.first     # => 1
  range.first = 1 # => NoMethodError

== Class Methods

--- new(first, last, exclude_end = false) -> Range

first から last までの範囲オブジェクトを生成して返しま
す。

exclude_end が真ならば終端を含まない範囲オブジェクトを生
成します。exclude_end 省略時には終端を含みます。

@param first 最初のオブジェクト
@param last 最後のオブジェクト
@param exclude_end 真をセットした場合終端を含まない範囲オブジェクトを生成します

@raise ArgumentError first <=> last が nil の場合に発生します

例: 整数の範囲オブジェクトの場合

  Range.new(1, 10)       # => 1..10
  Range.new(1, 10, true) # => 1...10

例: 日付オブジェクトの範囲オブジェクトの場合  

  require 'date'
  Range.new(Date.today, Date.today >> 1).each {|d| puts d }
  # => 2017-09-16
       2017-09-17
       ...
       2017-10-16
  
例: IPアドレスの範囲オブジェクトの場合

  require 'ipaddr'
  Range.new(IPAddr.new("192.0.2.1"), IPAddr.new("192.0.2.3")).each {|ip| puts ip}
  # => 192.0.2.1
       192.0.2.2
       192.0.2.3

例: 自作のオブジェクトの場合

  MyInteger = Struct.new(:value) do
    def succ
      self.class.new(value + 1)
    end

    def <=>(other)
      value <=> other.value
    end

    def to_s
      value.to_s
    end
  end
  Range.new(MyInteger.new(1), MyInteger.new(3)).each {|i| puts i }
  # => 1
       2
       3

== Instance Methods

#@until 2.6.0
--- ===(obj) -> bool
#@end
--- include?(obj) -> bool
--- member?(obj) -> bool

obj が範囲内に含まれている時に真を返します。

#@until 2.6.0
[[m:Range#===]] は主に case 式での比較に用いられます。
#@end

<=> メソッドによる演算により範囲内かどうかを判定するには [[m:Range#cover?]] を使用してください。

@param obj 比較対象のオブジェクトを指定します。

例:

  p (0.1 .. 0.2).member?(0.15)  # => true
  
  # 文字列の場合、include? は辞書順の比較になる
  p ("a" .. "c").include?("ba") # => false
  p ("a" .. "c").member?("ba")  # => false

@see [[ref:d:spec/control#case]]
@see [[m:Range#cover?]]

#@since 2.6.0
--- ===(obj) -> bool
#@end
--- cover?(obj) -> bool

obj が範囲内に含まれている時に真を返します。

#@since 2.6.0
[[m:Range#===]] は主に case 式での比較に用いられます。
#@end

[[m:Range#include?]] と異なり <=> メソッドによる演算により範囲内かどうかを判定します。
[[m:Range#include?]] は原則として離散値を扱い、
Range#cover? は連続値を扱います。
（数値については、例外として [[m:Range#include?]] も連続的に扱います。）

[[m:Range#exclude_end?]]がfalseなら「begin <= obj <= end」を、
trueなら「begin <= obj < end」を意味します。

#@since 2.6.0
引数がRangeオブジェクトの場合、引数の範囲がselfの範囲に含まれる時にtrueを返します。

「(a..b).cover?(c...d)」のように終端を含まないRangeオブジェクトが引数に渡されており、
「a <= c && b < d」を満たし、cが数値ではない(つまり引数のRangeの終端を
求めるためにsuccメソッドの呼び出しが必要な)場合、パフォーマンスの問題が起きる可能性があります。

#@samplecode パフォーマンス上の問題が起きる例
p ('aaaaa'..'zzzzy').cover?('aaaaa'...'zzzzz')
# => true
#@end

#@end

@param obj 比較対象のオブジェクトを指定します。

#@samplecode 数値は連続的に扱われているため、 include? / cover? が同じ結果を返す
(1.1..2.3).include?(1.0)    # => false
(1.1..2.3).include?(1.1)    # => true
(1.1..2.3).include?(1.555)  # => true
(1.1..2.3).cover?(1.0)      # => false
(1.1..2.3).cover?(1.1)      # => true
(1.1..2.3).cover?(1.555)    # => true
#@end

#@samplecode String の例
('b'..'d').include?('d')    # => true
('b'..'d').include?('ba')   # => false
('b'..'d').cover?('d')      # => true
('b'..'d').cover?('ba')     # => true
#@end

#@samplecode Date, DateTime の例
(Date.new(2014,1,3)..Date.new(2014,1,5)).include?(Date.new(2014,1,5))           # => true
(Time.new(2014,1,3)..Time.new(2014,1,5)).include?(Time.new(2014,1,4,10,10,10))  # => true
(Date.new(2014,1,3)..Date.new(2014,1,5)).cover?(Date.new(2014,1,5))             # => true
(Time.new(2014,1,3)..Time.new(2014,1,5)).cover?(Time.new(2014,1,4,10,10,10))    # => true
#@end

#@since 2.6.0
#@samplecode Range の例
(1..5).cover?(2..3)     #=> true
(1..5).cover?(0..6)     #=> false
(1..5).cover?(1...6)    #=> true
#@end

@see [[ref:d:spec/control#case]]
#@end

@see [[m:Range#include?]]

--- begin -> object
--- first -> object

始端の要素を返します。範囲オブジェクトが始端を含むかどうかは関係ありま
せん。

例:

  p (1..5).begin # => 1
  p (1..0).begin # => 1

@see [[m:Range#end]]

#@since 1.9.1
--- first(n) -> [object]

最初の n 要素を返します。範囲内に要素が含まれない場合は空の配列を返します。

@param n 取得する要素数を整数で指定します。整数以外のオブジェクトを指定
         した場合は to_int メソッドによる暗黙の型変換を試みます。

@raise TypeError 引数に整数以外の(暗黙の型変換が行えない)オブジェクトを
                 指定した場合に発生します。

@raise ArgumentError n に負の数を指定した場合に発生します。

例:

  (10..20).first(3)  # => [10, 11, 12]

@see [[m:Range#last]], [[ruby-core:12697]]
#@end

--- each {|item|  ... } -> self
#@since 1.9.1
--- each -> Enumerator
#@else
--- each -> Enumerable::Enumerator
#@end

範囲内の要素に対して繰り返します。

Range#each は各要素の succ メソッドを使用してイテレーションするようになりました。

@raise TypeError succ メソッドを持たないクラスの範囲オブジェクトに対してこのメソッドを呼んだ場合に発生します。


例:

  (10..15).each {|n| print n, ' ' }
  # prints: 10 11 12 13 14 15

  (2.5..5).each {|n| print n, ' ' }
  # raises: TypeError: can't iterate from Float

--- end -> object
--- last -> object

終端の要素を返します。範囲オブジェクトが終端を含むかどうかは関係ありま
せん。

例:

  (10..20).last      # => 20
  (10...20).last     # => 20

@see [[m:Range#begin]]

#@since 1.9.1
--- last(n) -> [object]

最後の n 要素を返します。範囲内に要素が含まれない場合は空の配列を返します。

@param n 取得する要素数を整数で指定します。整数以外のオブジェクトを指定
         した場合は to_int メソッドによる暗黙の型変換を試みます。

@raise TypeError 引数に整数以外の(暗黙の型変換が行えない)オブジェクトを
                 指定した場合に発生します。

@raise ArgumentError n に負の数を指定した場合に発生します。

[注意] 引数を省略して実行した場合は、終端を含むかどうか
([[m:Range#exclude_end?]] の戻り値)に関わらず終端の要素を返す事に注意し
てください。

例:

  (10..20).last(3)   # => [18, 19, 20]
  (10...20).last(3)  # => [17, 18, 19]

@see [[m:Range#first]]

#@# [[ruby-core:12697]]
#@end

--- exclude_end? -> bool

範囲オブジェクトが終端を含まないとき真を返します。

例:

  (1..5).exclude_end?     # => false
  (1...5).exclude_end?    # => true

--- step(s = 1) {|item| ... } -> self
--- step(s = 1) -> Enumerator
#@since 2.6.0
--- step(s = 1) -> Enumerator::ArithmeticSequence
--- %(s)        -> Enumerator
--- %(s)        -> Enumerator::ArithmeticSequence
#@end

範囲内の要素を s おきに繰り返します。

#@since 2.6.0
@param s 各ステップの大きさを数値で指定します。負の数を指定することもできます。
@return ブロックを指定した時は self を返します。
@return ブロックを指定しなかった時かつ数値の Range の時は [[c:Enumerator::ArithmeticSequence]] を返します。
@return ブロックを指定しなかったその他の Range の時は [[c:Enumerator]] を返します。(例: String の Range)
#@else
@param s 正の整数を指定します。
@return ブロックつきの時は self を返します。
@return ブロックなしの時は [[c:Enumerator]] を返します。
@raise ArgumentError s に 0 または負の数を指定した場合に発生します
#@end

例:

  ("a" .. "f").step(2) {|v| p v}
  # => "a"
       "c"
       "e"

--- ==(other)     -> bool

指定された other が Range クラスのインスタンスであり、
始端と終端が == メソッドで比較して等しく、[[m:Range#exclude_end?]] が同じ場合に
true を返します。そうでない場合に false を返します。

@param other 自身と比較したいオブジェクトを指定します。

例:

  p (1..2) == (1..2)               # => true
  p (1..2) == (1...2)              # => false
  p (1..2) == Range.new(1.0, 2.0)  # => true

--- eql?(other)   -> bool

指定された other が Range クラスのインスタンスであり、
始端と終端が eql? メソッドで比較して等しく、[[m:Range#exclude_end?]] が同じ場合に
true を返します。そうでない場合に false を返します。

@param other 自身と比較したいオブジェクトを指定します。

例:

  p (1..2).eql?(1..2)                 # => true
  p (1..2).eql?(1...2)                # => false
  p (1..2).eql?(Range.new(1.0, 2.0))  # => false

--- hash    -> Integer

始端と終端のハッシュ値と [[m:Range#exclude_end?]] の値からハッシュ値を計算して整数として返します。

例:

  p (1..2).hash    # => 5646
  p (1...2).hash   # => 16782863

--- to_s -> String

self を文字列に変換します(始端と終端のオブジェクトは #to_s メソッドで文
字列に変換されます)。

@see [[m:Range#inspect]]

例:
  (1..5).to_s      # => "1..5"
  ("1".."5").to_s  # => "1..5"

--- inspect -> String

self を文字列に変換します(始端と終端のオブジェクトは #inspect メソッド
で文字列に変換されます)。

@see [[m:Range#to_s]]

例:
  (1..5).inspect      # => "1..5"
  ("1".."5").inspect  # => "\"1\"..\"5\""

#@since 1.9.1
--- min               -> object | nil
#@since 2.2.0
--- min(n)            -> [object]
#@end

#@since 2.2.0
範囲内の最小の値、もしくは最小の n 要素を返します。
#@else
範囲内の最小の値を返します。
#@end

#@since 2.2.0
@param n 取得する要素数。
#@end

例:

   (1..5).min    # => 1
#@since 2.2.0
   (1..5).min(3) # => [1, 2, 3]
#@end

#@since 2.2.0
始端が終端より大きい場合、もしくは、終端を含まない範囲オブジェクトの始端が終端と
等しい場合は、引数を指定しない形式では nil を返します。
引数を指定する形式では、空の配列を返します。
#@else
始端が終端より大きい場合、もしくは、終端を含まない範囲オブジェクトの始端が終端と
等しい場合は nil を返します。
#@end

例:

   (2..1).min     # => nil
   (1...1).min    # => nil
#@since 2.2.0
   (2..1).min(3)  # => []
   (1...1).min(3) # => []
#@end

--- min {|a, b| ... } -> object | nil
#@since 2.2.0
--- min(n) {|a, b| ... } -> [object]
#@end

#@since 2.2.0
ブロックの評価結果で範囲内の各要素の大小判定を行い、最小の要素、もしくは
最小の n 要素を返します。引数を指定しない形式では、範囲内に要素が存在しなければ 
nil を返します。引数を指定する形式では、空の配列を返します。
#@else
ブロックの評価結果で範囲内の各要素の大小判定を行い、最小の要素を返しま
す。範囲内に要素が存在しなければ nil を返します。
#@end

ブロックの値は、a > b のとき正、a == b のとき 0、 a < b のとき負の整数
を、期待しています。

#@since 2.2.0
@param n 取得する要素数。
#@end

@raise TypeError ブロックが整数以外を返したときに発生します。

@see [[m:Range#first]], [[m:Range#max]], [[m:Enumerable#min]]

例:
  h = { 1 => "C", 2 => "Go", 3 => "Ruby" }
  (1..3).min { |a, b| h[a].length <=> h[b].length }    # => 1
#@since 2.2.0
  (1..3).min(2) { |a, b| h[a].length <=> h[b].length } # => [1, 2]
#@end

#@since 2.7.0
--- minmax                      -> [object, object]
--- minmax {|a, b| ... }        -> [object, object]

範囲内の要素のうち、最小の要素と最大の要素を要素とするサイズ 2 の配列を返します。

一つ目の形式では、全要素が互いに <=> メソッドで比較できることを仮定しています。

二つ目の形式では、要素同士の比較をブロックを用いて行います。
ブロックの値は、a > b のとき正、 a == b のとき 0、a < b のとき負の整数を、期待しています。

例:

  (1..3).minmax # => [1, 3]

  h = { 1 => "C", 2 => "Go", 3 => "Ruby" }
  (1..3).minmax { |a, b| h[a].length <=> h[b].length } # => [1, 3]

#@end

--- max               -> object | nil
#@since 2.2.0
--- max(n) -> [object]
#@end

#@since 2.2.0
範囲内の最大の値、もしくは最大の n 要素を返します。
#@else
範囲内の最大の値を返します。
#@end

#@since 2.2.0
@param n 取得する要素数。
#@end

例:

   (1..5).max     # => 5
#@since 2.2.0
   (1..5).max(3)  # => [5, 4, 3]
#@end

#@since 2.2.0
始端が終端より大きい場合、もしくは、終端を含まない範囲オブジェクトの始端が終端と
等しい場合は、引数を指定しない形式では nil を返します。
引数を指定する形式では、空の配列を返します。
#@else
始端が終端より大きい場合、もしくは、終端を含まない範囲オブジェクトの始端が終端と
等しい場合は nil を返します。
#@end

例:

   (2..1).max     # => nil
   (1...1).max    # => nil
#@since 2.2.0
   (2..1).max(3)  # => []
   (1...1).max(3) # => []
#@end

--- max {|a, b| ... } -> object | nil
#@since 2.2.0
--- max(n) {|a, b| ... } -> [object]
#@end

#@since 2.2.0
ブロックの評価結果で範囲内の各要素の大小判定を行い、最大の要素、もしくは
最大の n 要素を返します。引数を指定しない形式では、
範囲内に要素が存在しなければ nil を返します。
引数を指定する形式では、空の配列を返します。
#@else
ブロックの評価結果で範囲内の各要素の大小判定を行い、最大の要素を返しま
す。範囲内に要素が存在しなければ nil を返します。
#@end

ブロックの値は、a > b のとき正、 a == b のとき 0、a < b のとき負の整数
を、期待しています。

#@since 2.2.0
@param n 取得する要素数。
#@end

@raise TypeError ブロックが整数以外を返したときに発生します。

@see [[m:Range#last]], [[m:Range#min]], [[m:Enumerable#max]]
#@end

例:
  h = { 1 => "C", 2 => "Go", 3 => "Ruby" }
  (1..3).max { |a, b| h[a].length <=> h[b].length }    # => 3
#@since 2.2.0
  (1..3).max(2) { |a, b| h[a].length <=> h[b].length } # => [3, 2]
#@end

#@since 2.0.0
--- bsearch {|obj| ... } -> object | nil
--- bsearch              -> Enumerator

ブロックの評価結果で範囲内の各要素の大小判定を行い、条件を満たす値を二
分探索(計算量は O(log n))で検索します。要素が見つからない場合は nil を
返します。

本メソッドはブロックを評価した結果により以下のいずれかのモードで動作し
ます。

 * find-minimum モード
 * find-any モード

find-minimum モード(特に理由がない限りはこのモードを使う方がいいでしょ
う)では、条件判定の結果を以下のようにする必要があります。

 * 求める値がブロックパラメータの値か前の要素の場合: true を返す
 * 求める値がブロックパラメータより後の要素の場合: false を返す

ブロックの評価結果が true になる最初の要素を返すか、nil を返します。

例:

   ary = [0, 4, 7, 10, 12]
   (0...ary.size).bsearch {|i| ary[i] >= 4 } # => 1
   (0...ary.size).bsearch {|i| ary[i] >= 6 } # => 2
   (0...ary.size).bsearch {|i| ary[i] >= 8 } # => 3
   (0...ary.size).bsearch {|i| ary[i] >= 100 } # => nil

   (0.0...Float::INFINITY).bsearch {|x| Math.log(x) >= 0 } # => 1.0

find-any モードは [[man:bsearch(3)]] のように動作します。ブロックは真偽値
ではなく、以下のような数値を返す必要があります。求める値の範囲がx...y
（x <= y）であるとします。また、ブロックパラメータの値を v とします。

 * ブロックパラメータの値が求める値の範囲よりも小さい（v < x）場合: 正の数を返す
 * ブロックパラメータの値が求める値の範囲に合致する（x <= v < y）場合: 0 を返す
 * ブロックパラメータの値が求める値の範囲よりも大きい（y <= v）場合: 負の数を返す

ブロックの評価結果が 0 になるいずれかの要素を返すか、nil を返します。

例:

   ary = [0, 100, 100, 100, 200]
   (0..4).bsearch {|i| 100 - ary[i] } # => 1, 2 or 3
   (0..4).bsearch {|i| 300 - ary[i] } # => nil
   (0..4).bsearch {|i|  50 - ary[i] } # => nil

上記の 2 つのモードを混在して使用しないでください(ブロックの評価結果は
常に true/false、数値のいずれかを一貫して返すようにしてください)。
また、二分探索の各イテレーションで値がどのような順序で選ばれるかは
未規定です。

ブロックが与えられなかった場合は、 [[c:Enumerator]] のインスタンスを返します。

@raise TypeError ブロックの評価結果が true、false、nil、数値以外であっ
                 た場合に発生します。

@see [[m:Array#bsearch]]

--- size -> Integer | Float::INFINITY | nil

範囲内の要素数を返します。始端、終端のいずれかのオブジェクトが
[[c:Numeric]] のサブクラスのオブジェクトではない場合には nil を返します。

例:

  (10..20).size    # => 11
  ("a".."z").size  # => nil
  (-Float::INFINITY..Float::INFINITY).size # => Infinity
#@end
